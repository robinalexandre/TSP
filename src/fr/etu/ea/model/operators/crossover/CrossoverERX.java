package fr.etu.ea.model.operators.crossover;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import fr.etu.ea.model.Individu;
import fr.etu.ea.util.Utilities;

public class CrossoverERX implements ICrossover {

	@Override
	public Individu[] crossover(Individu parent1, Individu parent2) {
		Individu child1 = new Individu(this.edgeRecombinationOperator(parent1.getVilles(), parent2.getVilles()), parent1.getDistance());
		Individu child2 = new Individu(this.edgeRecombinationOperator(parent1.getVilles(), parent2.getVilles()), parent1.getDistance());
		Individu[] children = {child1, child2};
		return children;
	}

	/**
	 * Remove the specified city from the specified set of neighbors for each
	 * city.
	 * 
	 * @param city
	 *          The city to remove.
	 * @param neighborSets
	 *          The adjacency list as a mapping from city to a set of its neighbor
	 *          cities.
	 */
	protected static void removeFromAllNeighborSets(int city, Map<Integer, Set<Integer>> neighborSets) {
		for (Set<Integer> neighbors : neighborSets.values()) {
			neighbors.remove(city);
		}
	}

	/**
	 * Gets the single List returned by the edge recombination operator. Edge
	 * recombination crossover works as follows.
	 * 
	 * The edge recombination operator works as follows. First, an adjacency list
	 * is created, which maps each city to all of its neighbors in <em>either</em>
	 * tour. Second, a new tour is created by repeatedly choosing the city with
	 * the fewest neighbors as determined by the size of its adjacency list.
	 * 
	 * @param tour1
	 *          A tour.
	 * @param tour2
	 *          Another tour.
	 * @return The new tour generated by the edge recombination operator
	 *         algorithm.
	 * @throws CrossoverException
	 *           If there is a problem determining which cities satisfy the
	 *           condition of having a specific number of neighbors.
	 */
	protected List<Integer> edgeRecombinationOperator(List<Integer> tour1, List<Integer> tour2) {
		final Map<Integer, Set<Integer>> neighborsBothTours = new HashMap<Integer, Set<Integer>>();
		final int tourSize = tour1.size();
		Set<Integer> neighbors = null;
		for (int i = 0; i < tourSize; i++) {
			neighbors = new HashSet<Integer>();
			neighbors.add(tour1.get((i + tourSize - 1) % tourSize).intValue());
			neighbors.add(tour1.get((i + 1) % tourSize).intValue());
			neighbors.add(tour2.get((i + tourSize - 1) % tourSize).intValue());
			neighbors.add(tour2.get((i + 1) % tourSize).intValue());

			neighborsBothTours.put(i, neighbors);
		}

		// choose an initial city to add from a random parent
		int cityToAdd = 0;
		if (Utilities.random.nextBoolean()) {
			cityToAdd = tour1.get(0).intValue();
		} else {
			cityToAdd = tour2.get(0).intValue();
		}

		List<Integer> allPossibleCities = new ArrayList<Integer>();
		for (int i = 0; i < tourSize; i++) {
			allPossibleCities.add(i);
		}

		//		// create the condition which determines which cities have the same number
		//		// of neighbors
		//		SameNumberOfNeighborsCondition sameNumberOfNeighbors = new SameNumberOfNeighborsCondition(neighborsBothTours);

		final List<Integer> newTour = new ArrayList<>();

		int cityWithMinNeighbors = 0;
		int numberOfNeighbors = 0;
		List<Integer> citiesWithSameNumberOfNeighbors = null;
		while (newTour.size() < tourSize) {
			neighbors = neighborsBothTours.get(cityToAdd);
			if (neighbors.size() == 0) {
				cityToAdd = allPossibleCities.get(Utilities.random.nextInt(allPossibleCities.size()));

			} else {
				cityWithMinNeighbors = Collections.min(neighborsBothTours.get(cityToAdd), new Comparator<Integer>() {
					@Override
					public int compare(final Integer city1, final Integer city2) {
						return neighborsBothTours.get(city1).size() - neighborsBothTours.get(city2).size();
					}
				});

				numberOfNeighbors = neighborsBothTours.get(cityWithMinNeighbors).size();


				citiesWithSameNumberOfNeighbors = new ArrayList<>();
				for (Integer city : allPossibleCities) {
					if (numberOfNeighbors == neighborsBothTours.get(city).size()) {
						citiesWithSameNumberOfNeighbors.add(city);
					}
				}				
				cityToAdd = citiesWithSameNumberOfNeighbors.get(Utilities.random.nextInt(citiesWithSameNumberOfNeighbors.size()));

			}

			newTour.add(new Integer(cityToAdd));

			for (int i = 0; i < allPossibleCities.size(); i++) {
				if(allPossibleCities.get(i) == cityToAdd)
					allPossibleCities.remove(i);
			}
			for (Set<Integer> neigh : neighborsBothTours.values()) {
				neigh.remove(cityToAdd);
			}
		}

		return newTour;
	}
}
